<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gauss's Law Animation (Three.js)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
</head>
<body>
    <div id="info">
        <h1>Gauss's Law</h1>
        <p>Observe the flux through the transparent sphere.</p>
        <p>When the charge is *inside*, the flux is constant.</p>
        <p>When the charge is *outside*, the net flux is zero.</p>
        <p>Current Enclosed Charge: <span id="enclosedCharge"></span></p>
    </div>

    <script>
        let scene, camera, renderer;
        let pointCharge, gaussianSphere;
        let fieldLines = [];
        let animationPhase = 0; // 0: expand, 1: contract, 2: move out, 3: move back
        let clock = new THREE.Clock();
        let gui;
        let params = {
            sphereRadius: 1.0,
            chargeStrength: 1.0,
            numFieldLines: 20
        };

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Point Charge (Red sphere)
            const chargeGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const chargeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            pointCharge = new THREE.Mesh(chargeGeometry, chargeMaterial);
            scene.add(pointCharge);
            pointCharge.geometry.computeBoundingSphere(); // Ensure boundingSphere is computed

            // Gaussian Surface (Transparent blue sphere)
            const gaussianGeometry = new THREE.SphereGeometry(params.sphereRadius, 64, 64);
            const gaussianMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            gaussianSphere = new THREE.Mesh(gaussianGeometry, gaussianMaterial);
            scene.add(gaussianSphere);

            // Electric Field Lines
            createFieldLines();

            // Lights (optional, but good for shading)
            const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // GUI for parameters
            gui = new dat.GUI();
            gui.add(params, 'chargeStrength', 0.1, 2.0).name('Charge Strength');
            gui.add(params, 'numFieldLines', 10, 100, 1).name('Num Field Lines').onChange(createFieldLines);
            // gui.add(params, 'sphereRadius', 0.5, 5.0).name('Gaussian Radius'); // Not animated by GUI, but can be set

            // Window resizing
            window.addEventListener('resize', onWindowResize, false);
        }

        function createFieldLines() {
            // Remove existing lines
            fieldLines.forEach(line => scene.remove(line));
            fieldLines = [];

            const chargePosition = pointCharge.position;
            const lineLength = 10; // How far the lines extend

            for (let i = 0; i < params.numFieldLines; i++) {
                // Random direction using spherical coordinates
                const phi = Math.acos(2 * Math.random() - 1); // inclination
                const theta = 2 * Math.PI * Math.random();     // azimuth

                const x = chargePosition.x + lineLength * Math.sin(phi) * Math.cos(theta);
                const y = chargePosition.y + lineLength * Math.sin(phi) * Math.sin(theta);
                const z = chargePosition.z + lineLength * Math.cos(phi);

                const material = new THREE.LineBasicMaterial({ color: 0xffffff });
                const points = [];
                points.push(chargePosition);
                points.push(new THREE.Vector3(x, y, z));

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, material);
                fieldLines.push(line);
                scene.add(line);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            // Gaussian sphere animation
            const animationDuration = 5; // seconds per phase
            let currentPhaseTime = elapsedTime % (animationDuration * 4); // Loop through 4 phases

            let currentEnclosedCharge = 0; // Assume 0 by default

            // Phase 0: Expand
            if (currentPhaseTime < animationDuration) {
                const scale = 1 + (currentPhaseTime / animationDuration) * 3; // From 1 to 4
                gaussianSphere.scale.set(scale, scale, scale);
                gaussianSphere.position.set(0, 0, 0); // Keep it centered
                if (gaussianSphere.scale.x * params.sphereRadius > pointCharge.geometry.boundingSphere.radius) {
                    currentEnclosedCharge = params.chargeStrength;
                }
            }
            // Phase 1: Contract
            else if (currentPhaseTime < animationDuration * 2) {
                const phaseTime = currentPhaseTime - animationDuration;
                const scale = 4 - (phaseTime / animationDuration) * 3; // From 4 to 1
                gaussianSphere.scale.set(scale, scale, scale);
                gaussianSphere.position.set(0, 0, 0);
                 if (gaussianSphere.scale.x * params.sphereRadius > pointCharge.geometry.boundingSphere.radius) {
                    currentEnclosedCharge = params.chargeStrength;
                }
            }
            // Phase 2: Move out (away from charge)
            else if (currentPhaseTime < animationDuration * 3) {
                const phaseTime = currentPhaseTime - animationDuration * 2;
                const moveDistance = 5 * (phaseTime / animationDuration); // Moves up to 5 units
                gaussianSphere.position.set(moveDistance, 0, 0); // Move along X-axis
                gaussianSphere.scale.set(1, 1, 1); // Keep original scale
                // Check if charge is inside
                const distance = gaussianSphere.position.distanceTo(pointCharge.position);
                if (distance < (params.sphereRadius * gaussianSphere.scale.x)) {
                    currentEnclosedCharge = params.chargeStrength;
                } else {
                    currentEnclosedCharge = 0;
                }
            }
            // Phase 3: Move back (to enclose charge)
            else {
                const phaseTime = currentPhaseTime - animationDuration * 3;
                const moveDistance = 5 - (5 * (phaseTime / animationDuration)); // Moves back from 5 to 0 units
                gaussianSphere.position.set(moveDistance, 0, 0);
                gaussianSphere.scale.set(1, 1, 1);
                // Check if charge is inside
                const distance = gaussianSphere.position.distanceTo(pointCharge.position);
                if (distance < (params.sphereRadius * gaussianSphere.scale.x)) {
                    currentEnclosedCharge = params.chargeStrength;
                } else {
                    currentEnclosedCharge = 0;
                }
            }

            // Update UI for enclosed charge
            document.getElementById('enclosedCharge').innerText = currentEnclosedCharge.toFixed(2);


            // Simple camera rotation for better view
            camera.position.x = Math.sin(elapsedTime * 0.1) * 10;
            camera.position.z = Math.cos(elapsedTime * 0.1) * 10;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        // Initialize Bounding Sphere for charge after creation
        pointCharge.geometry.computeBoundingSphere();

    </script>
</body>
</html>